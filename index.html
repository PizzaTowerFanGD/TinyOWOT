<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TinyOWOT</title>
    <style>
        body { margin: 0; overflow: hidden; background: #eee; font-family: 'Courier New', monospace; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; image-rendering: pixelated; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; background: rgba(255,255,255,0.9); border: 1px solid #999; padding: 5px; margin: 5px; display: inline-block; vertical-align: top; font-size: 13px; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); }
        
        .color-picker { display: flex; gap: 3px; margin-top: 5px; }
        .color-swatch { width: 22px; height: 22px; border: 1px solid #000; cursor: pointer; border-radius: 2px; }
        .active-color { outline: 3px solid #007bff; z-index: 1; }
        .active-deco { background: #007bff; color: white; }

        #chat-panel { position: fixed; bottom: 0; right: 0; width: 300px; height: 220px; display: flex; flex-direction: column; margin: 0; border: 1px solid #999; }
        #messages { flex: 1; overflow-y: auto; background: white; font-size: 12px; padding: 5px; }
        #chat-input { width: 100%; box-sizing: border-box; padding: 10px; border: none; border-top: 1px solid #999; font-size: 14px; pointer-events: auto; }
        
        #hidden-input { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; border: none; padding: 0; z-index: -1; pointer-events: none; }
        
        button { cursor: pointer; padding: 4px 8px; font-size: 12px; }
        #coords { position: fixed; bottom: 5px; left: 5px; font-size: 10px; color: #666; pointer-events: none; }

        .system { color: #888; font-style: italic; }
        .error { color: #d00; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="panel">
        <strong>Tools</strong><br>
        Text Color: <span id="cur-col-name">Black</span>
        <div class="color-picker" id="palette"></div>
        <div style="margin-top:5px;">
            <label style="font-size: 11px;">Custom: </label>
            <input type="color" id="custom-color" value="#000000" style="width: 30px; height: 22px; border: 1px solid #000; cursor: pointer;">
        </div>
        <div style="margin-top:8px;">
            <label style="font-size: 11px;"><input type="checkbox" id="use-cell-color"> Use Cell Color</label>
            <br>
            <label style="font-size: 11px;">Cell Color: </label>
            <input type="color" id="custom-cell-color" value="#ffffff" style="width: 30px; height: 22px; border: 1px solid #000; cursor: pointer;">
        </div>
        <div style="margin-top:8px;">
            <button id="btn-bold" onclick="toggleDeco('bold')">B</button>
            <button id="btn-italic" onclick="toggleDeco('italic')">I</button>
            <button id="btn-underline" onclick="toggleDeco('underline')">U</button>
            <button id="btn-strike" onclick="toggleDeco('strike')">S</button>
        </div>
        <div style="margin-top:8px;">
            <button onclick="promptLink('url')">URL</button>
            <button onclick="promptLink('coord')">Coord</button>
            <button onclick="promptLink('note')">Note</button>
        </div>
    </div>
    
    <div id="link-info" class="panel" style="display:none; border-color: #007bff;">
        <strong>Link:</strong> <span id="link-display"></span>
        <button id="link-action-btn">Go</button>
    </div>
</div>

<div id="chat-panel" class="panel">
    <div id="messages"></div>
    <input type="text" id="chat-input" placeholder="Chat or /help...">
</div>

<div id="coords">X: 0, Y: 0</div>
<input type="text" id="hidden-input" autocomplete="off" autocapitalize="off" spellcheck="false">

<canvas id="world"></canvas>

<script>
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    const hiddenInput = document.getElementById('hidden-input');
    const chatInput = document.getElementById('chat-input');
    const msgBox = document.getElementById('messages');
    
    // Config
    const TILE_W = 16, TILE_H = 8;
    const CHAR_W = 10, CHAR_H = 20;
    const PALETTE = [0x000000, 0xFF0000, 0x00FF00, 0x0000FF, 0xFF00FF, 0x00FFFF, 0x7F7F7F, 0xFFFF00];
    const PALETTE_NAMES = ["Black", "Red", "Green", "Blue", "Magenta", "Cyan", "Gray", "Yellow"];

    let cameraX = 0, cameraY = 0;
    let tiles = {};
    let selectedCell = { tx: 0, ty: 0, cx: 0, cy: 0 };
    let currentColor = 0x000000; // Store as decimal hex value
    let currentCellColor = 0xffffff; // Store as decimal hex value
    let useCellColor = false;
    let decorations = { bold: false, italic: false, underline: false, strike: false };
    const TEXT_DECORATION_OFFSET = 0x20F0;
    let nickname = "User" + Math.floor(Math.random()*100);
    let ws = null;

    // --- Networking & Commands ---

    function connect(url) {
        if (ws) ws.close();
        addChatMessage("System", `Connecting to ${url}...`, "system");
        
        ws = new WebSocket(url);
        ws.onopen = () => {
            addChatMessage("System", "Connected!", "system");
            fetchVisibleTiles();
        };

        ws.onmessage = (msg) => {
            const data = JSON.parse(msg.data);
            if (data.kind === "fetch" || data.kind === "tileUpdate") {
                Object.assign(tiles, data.tiles);
                render();
            }
            if (data.kind === "chat") {
                addChatMessage(data.nickname || ("ID:"+data.id), data.message);
            }
        };

        ws.onerror = () => addChatMessage("Error", "Connection failed.", "error");
    }

    function addChatMessage(sender, text, className = "") {
        const div = document.createElement('div');
        if(className) div.className = className;
        div.innerHTML = `<b>${sender}:</b> ${text.replaceAll("<","").replaceAll(">","")}`;
        msgBox.appendChild(div);
        msgBox.scrollTop = msgBox.scrollHeight;
    }

    function processCommand(val) {
        if (val.startsWith("/help")) {
            addChatMessage("Help", "/nick [name], /warp [url], /help", "system");
        } else if (val.startsWith("/nick ")) {
            nickname = val.replace("/nick ", "").trim() || "Anon";
            addChatMessage("System", `Name set to: ${nickname}`, "system");
        } else if (val.startsWith("/warp ")) {
            const url = val.replace("/warp ", "").trim();
            connect(url.includes("://") ? url : "ws://" + url);
        } else {
            // Standard Chat
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ kind: "chat", message: val, nickname: nickname }));
            }
        }
    }

    // --- Tile & Writing Logic (Optimistic) ---

    function encodeTextDecorations(char) {
        const bitmap = (decorations.bold ? 8 : 0) | (decorations.italic ? 4 : 0) | (decorations.underline ? 2 : 0) | (decorations.strike ? 1 : 0);
        if (bitmap === 0) return char;
        return char + String.fromCharCode(TEXT_DECORATION_OFFSET + bitmap);
    }

    function parseTextDecorations(charStr) {
        let char = charStr[0];
        let bold = false, italic = false, underline = false, strike = false;

        if (charStr.length > 1) {
            for (let i = 1; i < charStr.length; i++) {
                const code = charStr.charCodeAt(i);
                if (code >= TEXT_DECORATION_OFFSET && code <= TEXT_DECORATION_OFFSET + 15) {
                    const bitmap = code - TEXT_DECORATION_OFFSET;
                    bold = bold || !!(bitmap & 8);
                    italic = italic || !!(bitmap & 4);
                    underline = underline || !!(bitmap & 2);
                    strike = strike || !!(bitmap & 1);
                }
            }
        }
        return { char, bold, italic, underline, strike };
    }

    function toggleDeco(type) {
        decorations[type] = !decorations[type];
        const btn = document.getElementById('btn-' + type);
        btn.classList.toggle('active-deco', decorations[type]);
    }

    function getLocalTile(tx, ty) {
        const key = `${ty},${tx}`;
        if (!tiles[key]) {
            tiles[key] = {
                content: new Array(128).fill(" "),
                properties: { writability: 0, color: new Array(128).fill(0), bgcolor: new Array(128).fill(-1), cell_props: {} }
            };
        }
        return tiles[key];
    }

    function handleWrite(char) {
        const { tx, ty, cx, cy } = selectedCell;
        const tile = getLocalTile(tx, ty);

        // Encode decorations
        const encodedChar = encodeTextDecorations(char);

        // Optimistic Update: Change locally immediately
        const idx = cy * 16 + cx;
        tile.content[idx] = encodedChar;
        tile.properties.color[idx] = currentColor;
        if (useCellColor) {
            tile.properties.bgcolor[idx] = currentCellColor;
        }

        // Send to server
        if (ws && ws.readyState === WebSocket.OPEN) {
            const editArray = [ty, tx, cy, cx, Date.now(), encodedChar, Math.random()];
            const hasActiveColor = document.querySelector('.active-color');
            const hasTextColor = hasActiveColor || currentColor !== 0;

            if (hasTextColor) {
                editArray.push(currentColor);
            }

            if (useCellColor) {
                if (!hasTextColor) {
                    editArray.push(0); // Placeholder for text color if no color selected
                }
                editArray.push(currentCellColor);
            }

            ws.send(JSON.stringify({
                kind: "write",
                edits: [editArray]
            }));
        }

        // Advance cursor
        selectedCell.cx++;
        if (selectedCell.cx >= 16) { selectedCell.cx = 0; selectedCell.tx++; }
        render();
    }

    // --- Rendering ---

    function render() {
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = `${CHAR_H}px monospace`;
        ctx.textBaseline = "top";

        const startTX = Math.floor(cameraX / 160);
        const endTX = Math.ceil((cameraX + canvas.width) / 160);
        const startTY = Math.floor(cameraY / 160);
        const endTY = Math.ceil((cameraY + canvas.height) / 160);

        for (let ty = startTY; ty <= endTY; ty++) {
            for (let tx = startTX; tx <= endTX; tx++) {
                const tile = tiles[`${ty},${tx}`];
                const xPos = tx * 160 - cameraX;
                const yPos = ty * 160 - cameraY;

                if (tile && tile.properties.writability === 2) {
                    ctx.fillStyle = "#e0e0e0";
                    ctx.fillRect(xPos, yPos, 160, 160);
                }

                ctx.strokeStyle = "#ddd";
                ctx.strokeRect(xPos, yPos, 160, 160);

                if (tile) {
                    for (let cy = 0; cy < TILE_H; cy++) {
                        for (let cx = 0; cx < TILE_W; cx++) {
                            const idx = cy * 16 + cx;
                            const charStr = tile.content[idx] || " ";
                            const colorValue = tile.properties.color[idx] || 0;
                            const bgColorValue = tile.properties.bgcolor && tile.properties.bgcolor[idx];
                            const charX = xPos + (cx * CHAR_W);
                            const charY = yPos + (cy * CHAR_H);

                            // Cell background color
                            if (bgColorValue !== undefined && bgColorValue !== -1) {
                                ctx.fillStyle = '#' + bgColorValue.toString(16).padStart(6, '0');
                                ctx.fillRect(charX, charY, CHAR_W, CHAR_H);
                            }

                            // Link underline
                            const cp = tile.properties.cell_props[cy] && tile.properties.cell_props[cy][cx];
                            if (cp && cp.link) {
                                ctx.beginPath();
                                if (cp.link.type === 'url') { ctx.strokeStyle = "blue"; ctx.setLineDash([]); }
                                else if (cp.link.type === 'coord') { ctx.strokeStyle = "green"; ctx.setLineDash([]); }
                                else { ctx.strokeStyle = "#444"; ctx.setLineDash([2, 2]); }
                                ctx.moveTo(charX, charY + 18); ctx.lineTo(charX + 10, charY + 18);
                                ctx.stroke(); ctx.setLineDash([]);
                            }

                            // Parse decorations and render character
                            const { char, bold, italic, underline, strike } = parseTextDecorations(charStr);
                            if (char !== " " && char !== undefined) {
                                // Handle both palette indices (for backwards compatibility) and direct color values
                                const color = (colorValue < 8) ? PALETTE[colorValue] : colorValue;
                                ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');

                                // Apply font styles
                                let fontStr = `${CHAR_H}px monospace`;
                                if (italic) fontStr = 'italic ' + fontStr;
                                if (bold) fontStr = 'bold ' + fontStr;
                                ctx.font = fontStr;

                                ctx.fillText(char, charX, charY);

                                // Manual underline and strikethrough (canvas doesn't support these in font)
                                if (underline) {
                                    ctx.beginPath();
                                    ctx.strokeStyle = ctx.fillStyle;
                                    ctx.lineWidth = 1;
                                    ctx.moveTo(charX, charY + 18);
                                    ctx.lineTo(charX + 10, charY + 18);
                                    ctx.stroke();
                                }
                                if (strike) {
                                    ctx.beginPath();
                                    ctx.strokeStyle = ctx.fillStyle;
                                    ctx.lineWidth = 1;
                                    ctx.moveTo(charX, charY + 10);
                                    ctx.lineTo(charX + 10, charY + 10);
                                    ctx.stroke();
                                }
                                ctx.lineWidth = 1;
                            }
                        }
                    }
                }
            }
        }

        // Selection Cursor
        ctx.strokeStyle = "#007bff";
        ctx.lineWidth = 2;
        ctx.strokeRect(selectedCell.tx * 160 + selectedCell.cx * 10 - cameraX, 
                       selectedCell.ty * 160 + selectedCell.cy * 20 - cameraY, 10, 20);
        ctx.lineWidth = 1;
    }

    // --- Interaction ---

    function fetchVisibleTiles() {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const minTX = Math.floor(cameraX / 160) - 1;
        const maxTX = Math.ceil((cameraX + canvas.width) / 160) + 1;
        const minTY = Math.floor(cameraY / 160) - 1;
        const maxTY = Math.ceil((cameraY + canvas.height) / 160) + 1;
        ws.send(JSON.stringify({ kind: "fetch", fetchRectangles: [{ minX: minTX, maxX: maxTX, minY: minTY, maxY: maxTY }], request: "view" }));
    }

    let isDragging = false, lastMouse = { x: 0, y: 0 }, tapStart = { x: 0, y: 0 };

    canvas.addEventListener('pointerdown', (e) => {
        isDragging = true;
        lastMouse = { x: e.clientX, y: e.clientY };
        tapStart = { x: e.clientX, y: e.clientY };
    });

    window.addEventListener('pointermove', (e) => {
        if (isDragging) {
            cameraX -= (e.clientX - lastMouse.x);
            cameraY -= (e.clientY - lastMouse.y);
            lastMouse = { x: e.clientX, y: e.clientY };
            document.getElementById('coords').innerText = `X: ${Math.floor(cameraX/10)}, Y: ${Math.floor(cameraY/20)}`;
            render();
        }
    });

    window.addEventListener('pointerup', (e) => {
        const dist = Math.hypot(e.clientX - tapStart.x, e.clientY - tapStart.y);
        if (dist < 10) {
            const worldX = e.clientX + cameraX;
            const worldY = e.clientY + cameraY;
            selectedCell.tx = Math.floor(worldX / 160);
            selectedCell.ty = Math.floor(worldY / 160);
            selectedCell.cx = Math.floor((((worldX % 160) + 160) % 160) / 10);
            selectedCell.cy = Math.floor((((worldY % 160) + 160) % 160) / 20);
            setTimeout(() => { hiddenInput.focus(); hiddenInput.click(); }, 10);
            checkLinkAtCursor();
        } else {
            fetchVisibleTiles();
        }
        isDragging = false;
        render();
    });

    hiddenInput.addEventListener('input', (e) => {
        const char = e.data || e.target.value.slice(-1);
        if (char) handleWrite(char);
        hiddenInput.value = ""; 
    });

    window.addEventListener('keydown', (e) => {
        if (document.activeElement === chatInput) return;
        if (e.key === "Backspace") {
            // Write a plain space without decorations
            const { tx, ty, cx, cy } = selectedCell;
            const tile = getLocalTile(tx, ty);
            const idx = cy * 16 + cx;
            tile.content[idx] = " ";
            tile.properties.color[idx] = 0;
            tile.properties.bgcolor[idx] = -1;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    kind: "write",
                    edits: [[ty, tx, cy, cx, Date.now(), " ", Math.random(), 0]]
                }));
            }

            selectedCell.cx -= 1;
            if(selectedCell.cx < 0) { selectedCell.cx = 15; selectedCell.tx--; }
            render();
        }
        if (e.key.startsWith("Arrow")) {
            if (e.key === "ArrowRight") selectedCell.cx++;
            if (e.key === "ArrowLeft") selectedCell.cx--;
            if (e.key === "ArrowUp") selectedCell.cy--;
            if (e.key === "ArrowDown") selectedCell.cy++;
            render();
        }
    });

    chatInput.addEventListener('keydown', e => {
        if (e.key === 'Enter' && chatInput.value.trim()) {
            processCommand(chatInput.value);
            chatInput.value = "";
            chatInput.blur();
        }
    });

    function checkLinkAtCursor() {
        const tile = tiles[`${selectedCell.ty},${selectedCell.tx}`];
        const ui = document.getElementById('link-info');
        if (tile && tile.properties.cell_props[selectedCell.cy] && tile.properties.cell_props[selectedCell.cy][selectedCell.cx]) {
            const data = tile.properties.cell_props[selectedCell.cy][selectedCell.cx];
            ui.style.display = 'inline-block';
            const display = document.getElementById('link-display');
            const btn = document.getElementById('link-action-btn');
            btn.style.display = 'inline-block';
            if (data.link.type === 'url') {
                display.innerText = data.link.url;
                btn.innerText = "Open";
                btn.onclick = () => window.open(data.link.url.startsWith('http') ? data.link.url : 'http://'+data.link.url, '_blank');
            } else if (data.link.type === 'coord') {
                display.innerText = `To ${data.link.link_tileX}, ${data.link.link_tileY}`;
                btn.innerText = "Jump";
                btn.onclick = () => { cameraX = data.link.link_tileX*160 - canvas.width/2; cameraY = data.link.link_tileY*160 - canvas.height/2; fetchVisibleTiles(); render(); };
            } else { display.innerText = "Note"; btn.style.display = 'none'; }
        } else { ui.style.display = 'none'; }
    }

    function promptLink(type) {
        if (type === 'url') { const url = prompt("URL:"); if (url) sendLinkUpdate({ type: 'url', url }); }
        else if (type === 'coord') { const tx = prompt("Tile X:"), ty = prompt("Tile Y:"); if (tx) sendLinkUpdate({ type: 'coord', link_tileX: parseInt(tx), link_tileY: parseInt(ty) }); }
        else sendLinkUpdate({ type: 'note' });
    }

    function sendLinkUpdate(ld) {
        ws.send(JSON.stringify({ kind: "link", type: ld.type, tileX: selectedCell.tx, tileY: selectedCell.ty, charX: selectedCell.cx, charY: selectedCell.cy, data: ld }));
    }

    // Init Palette
    const p = document.getElementById('palette');
    PALETTE.forEach((color, i) => {
        const s = document.createElement('div');
        s.className = 'color-swatch' + (i === 0 ? ' active-color' : '');
        s.style.backgroundColor = '#' + color.toString(16).padStart(6, '0');
        s.onclick = () => {
            document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('active-color'));
            s.classList.add('active-color');
            currentColor = color; // Store the actual color value
            document.getElementById('cur-col-name').innerText = PALETTE_NAMES[i];
        };
        p.appendChild(s);
    });

    // Custom Color Picker
    const customColorInput = document.getElementById('custom-color');
    customColorInput.addEventListener('input', (e) => {
        const hexColor = e.target.value; // e.g. "#ff00aa"
        currentColor = parseInt(hexColor.slice(1), 16); // Convert to decimal (0xff00aa)
        document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('active-color'));
        document.getElementById('cur-col-name').innerText = hexColor.toUpperCase();
    });

    // Cell Color
    const useCellColorCheckbox = document.getElementById('use-cell-color');
    const customCellColorInput = document.getElementById('custom-cell-color');
    customCellColorInput.addEventListener('input', (e) => {
        const hexColor = e.target.value;
        currentCellColor = parseInt(hexColor.slice(1), 16);
    });

    useCellColorCheckbox.addEventListener('change', (e) => {
        useCellColor = e.target.checked;
    });

    window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; render(); });
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    connect(`wss://${location.host}`);
</script>
</body>
</html>
