<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TinyOWOT</title>
    <style>
        body { margin: 0; overflow: hidden; background: #f0f0f0; font-family: monospace; touch-action: none; }
        canvas { display: block; }

        /* The Secret Sauce: A hidden input that is technically "visible" to the browser */
        #mobile-input-field {
            position: absolute;
            left: 50%;
            top: 50%;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            width: 1px;
            height: 1px;
            font-size: 16px; /* Prevents iOS from zooming in on focus */
        }

        #ui { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; border: 1px solid #ccc; pointer-events: none; }
        .kb-status { color: green; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">
        Tap anywhere to type<br>
        <span id="coords">X: 0, Y: 0</span><br>
        <span id="kb-indicator">Keyboard: Hidden</span>
    </div>

    <!-- This input field is what triggers the virtual keyboard -->
    <input type="text" id="mobile-input-field" autocomplete="off" autocapitalize="off" spellcheck="false">

    <canvas id="world"></canvas>

<script>
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    const mobileInput = document.getElementById('mobile-input-field');
    const kbIndicator = document.getElementById('kb-indicator');
    
    let cameraX = 0, cameraY = 0;
    let tiles = {};
    let selectedCell = { tx: 0, ty: 0, cx: 0, cy: 0 };
    let ws;

    // Connect to WebSocket
    function connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(`${protocol}//${location.host}`);
        ws.onopen = () => fetchVisibleTiles();
        ws.onmessage = (msg) => {
            const data = JSON.parse(msg.data);
            if (data.kind === "fetch" || data.kind === "tileUpdate") {
                Object.assign(tiles, data.tiles);
                render();
            }
        };
    }

    function fetchVisibleTiles() {
        if (ws.readyState !== WebSocket.OPEN) return;
        const minTX = Math.floor(cameraX / 160);
        const maxTX = Math.ceil((cameraX + canvas.width) / 160);
        const minTY = Math.floor(cameraY / 160);
        const maxTY = Math.ceil((cameraY + canvas.height) / 160);
        ws.send(JSON.stringify({
            kind: "fetch",
            fetchRectangles: [{ minX: minTX, maxX: maxTX, minY: minTY, maxY: maxTY }],
            request: "view"
        }));
    }

    // --- Input Logic ---

    // 1. Tapping the canvas
    canvas.addEventListener('pointerdown', (e) => {
        // Calculate grid position
        const worldX = e.clientX + cameraX;
        const worldY = e.clientY + cameraY;
        selectedCell.tx = Math.floor(worldX / 160);
        selectedCell.ty = Math.floor(worldY / 160);
        selectedCell.cx = Math.floor((((worldX % 160) + 160) % 160) / 10);
        selectedCell.cy = Math.floor((((worldY % 160) + 160) % 160) / 20);

        // FORCE KEYBOARD
        mobileInput.focus();
        kbIndicator.innerText = "Keyboard: ACTIVE";
        kbIndicator.classList.add("kb-status");

        render();
    });

    // 2. Handling the text input from virtual keyboard
    mobileInput.addEventListener('input', (e) => {
        const char = e.data || e.target.value.slice(-1); // Handle different mobile event types
        if (char) {
            writeChar(char);
            e.target.value = ""; // Clear for next character
        }
    });

    // Handle Backspace
    mobileInput.addEventListener('keydown', (e) => {
        if (e.key === "Backspace") {
            writeChar(" ");
        }
    });

    function writeChar(char) {
        ws.send(JSON.stringify({
            kind: "write",
            edits: [[selectedCell.ty, selectedCell.tx, selectedCell.cy, selectedCell.cx, Date.now(), char, Math.random()]]
        }));
        
        // Advance cursor
        selectedCell.cx++;
        if (selectedCell.cx >= 16) {
            selectedCell.cx = 0;
            selectedCell.tx++;
        }
        render();
    }

    // --- Rendering Logic ---
    function render() {
        ctx.fillStyle = "#f0f0f0";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = `20px monospace`;
        ctx.textBaseline = "top";

        const startTX = Math.floor(cameraX / 160);
        const endTX = Math.ceil((cameraX + canvas.width) / 160);
        const startTY = Math.floor(cameraY / 160);
        const endTY = Math.ceil((cameraY + canvas.height) / 160);

        for (let ty = startTY; ty <= endTY; ty++) {
            for (let tx = startTX; tx <= endTX; tx++) {
                const tile = tiles[`${ty},${tx}`];
                const xPos = tx * 160 - cameraX;
                const yPos = ty * 160 - cameraY;

                ctx.strokeStyle = "#ddd";
                ctx.strokeRect(xPos, yPos, 160, 160);

                if (tile) {
                    ctx.fillStyle = "#000";
                    for (let i = 0; i < 128; i++) {
                        const cx = i % 16;
                        const cy = Math.floor(i / 16);
                        const char = tile.content[i];
                        if (char !== " ") {
                            ctx.fillText(char, xPos + (cx * 10), yPos + (cy * 20));
                        }
                    }
                }
            }
        }

        // Draw selection cursor
        ctx.strokeStyle = "blue";
        ctx.strokeRect(
            selectedCell.tx * 160 + selectedCell.cx * 10 - cameraX,
            selectedCell.ty * 160 + selectedCell.cy * 20 - cameraY,
            10, 20
        );
    }

    // Dragging Logic
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };
    window.addEventListener('pointermove', (e) => {
        if (isDragging) {
            cameraX -= (e.clientX - lastMouse.x);
            cameraY -= (e.clientY - lastMouse.y);
            lastMouse = { x: e.clientX, y: e.clientY };
            document.getElementById('coords').innerText = `X: ${Math.floor(cameraX/10)}, Y: ${Math.floor(cameraY/20)}`;
            render();
        }
    });
    window.addEventListener('pointerdown', (e) => { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; });
    window.addEventListener('pointerup', () => { isDragging = false; fetchVisibleTiles(); });

    // Resize handling
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
    });

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    connect();
</script>
</body>
</html>
