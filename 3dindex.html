<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D TinyOWOT</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: monospace; background: #000; color: #fff; overflow: hidden; }
#container { position: relative; width: 100vw; height: 100vh; }
#canvas { position: absolute; top: 0; left: 0; background: #111; cursor: crosshair; }
#hud { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 4px; font-size: 14px; }
#controls { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 4px; }
#mobileControls { position: absolute; bottom: 10px; right: 10px; display: none; }
.dpad { display: grid; grid-template-columns: repeat(3, 60px); gap: 5px; }
.dpad button { width: 60px; height: 60px; font-size: 20px; background: #333; color: #fff; border: none; border-radius: 8px; }
.dpad button:active { background: #555; }
#chat { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 600px; }
#chatInput { width: 100%; padding: 8px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px; }
#textInput { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; padding: 10px; border-radius: 4px; display: none; }
#textInput input { background: #333; color: #fff; border: 1px solid #555; padding: 5px; margin: 5px; }
#dirSelect { margin: 5px; }
</style>
</head>
<body>
<div id="container">
<canvas id="canvas"></canvas>
<div id="hud">
<div>pos: <span id="pos"></span></div>
<div>dir: <span id="dir"></span></div>
<div>mode: <span id="mode">move</span></div>
</div>
<div id="controls">
<input type="color" id="colorPicker" value="#00ff00">
<button id="writeBtn" title="Write Mode (W)">W</button>
<button id="deleteBtn" title="Delete Mode (D)">D</button>
<button id="toggleMobile">Mobile</button>
</div>
<div id="mobileControls">
<div class="dpad">
<button id="mUp">↑</button>
<button id="mLeft">←</button>
<button id="mDown">↓</button>
<button id="mRight">→</button>
<button id="mYup">Y+</button>
<button id="mYdown">Y-</button>
</div>
</div>
<div id="chat">
<input type="text" id="chatInput" placeholder="chat... (enter to send)">
</div>
<div id="textInput">
<input type="text" id="charInput" placeholder="character" maxlength="1">
<select id="dirSelect">
<option value="x+">→ X+</option>
<option value="x-">← X-</option>
<option value="y+">↓ Y+</option>
<option value="y-">↑ Y-</option>
<option value="z+">⊗ Z+</option>
<option value="z-">⊙ Z-</option>
</select>
<button id="confirmText">OK</button>
<button id="cancelText">Cancel</button>
</div>
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const posEl = document.getElementById('pos');
const dirEl = document.getElementById('dir');
const modeEl = document.getElementById('mode');

let ws = null;
let wsId = null;
let camera = { x: 0, y: 0, z: 0, pitch: 0, yaw: 0 };
let keys = {};
let mouseDown = false;
let lastMouseX = 0, lastMouseY = 0;
let mode = 'move';
let selectedColor = 0x00ff00;
let tiles = {};
let cursors = {};
let isMobile = false;

function resize() {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function project(x, y, z) {
const scale = 30;
const cx = canvas.width / 2;
const cy = canvas.height / 2;
const dx = x - camera.x;
const dy = y - camera.y;
const dz = z - camera.z;
const px = (dx - dz) * scale + cx;
const py = (dx + dz) * scale * 0.5 - dy * scale + cy;
return { x: px, y: py };
}

function isTileVisible(x, y, z) {
const proj = project(x, y, z);
return proj.x > -100 && proj.x < canvas.width + 100 && proj.y > -100 && proj.y < canvas.height + 100;
}

function drawTile(x, y, z, tile) {
if (!tile) return;
const proj = project(x, y, z);
if (!isTileVisible(x, y, z)) return;
for (let i = 0; i < 128; i++) {
    const char = tile.content[i];
    if (!char || char === " ") continue;
    const dir = tile.directions[i] || "x+";
    const color = tile.properties.color[i] || 0xffffff;
    const bgcolor = tile.properties.bgcolor[i];
    const gx = i % 16;
    const gy = Math.floor(i / 16);
    const sp = 16;
    const px = proj.x + gx * sp;
    const py = proj.y + gy * sp;
    if (bgcolor !== -1) {
        ctx.fillStyle = "#" + bgcolor.toString(16).padStart(6, '0');
        ctx.fillRect(px, py, sp, sp);
    }
    ctx.save();
    ctx.translate(px + sp/2, py + sp/2);
    let rot = 0, scale = 1;
    if (dir === "x-") { ctx.scale(-1, 1); }
    else if (dir === "y+") { rot = Math.PI/2; }
    else if (dir === "y-") { rot = -Math.PI/2; }
    else if (dir === "z+") { scale = 0.5; }
    else if (dir === "z-") { scale = 1.5; }
    ctx.rotate(rot);
    ctx.scale(scale, scale);
    ctx.fillStyle = "#" + color.toString(16).padStart(6, '0');
    ctx.font = (12 * scale) + "px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(char, 0, 0);
    ctx.restore();
}
}

function draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
const visible = [];
for (const key in tiles) {
    const [x, y, z] = key.split(',').map(Number);
    visible.push({ x, y, z, key });
}
visible.sort((a, b) => {
    const da = Math.pow(a.x - camera.x, 2) + Math.pow(a.y - camera.y, 2) + Math.pow(a.z - camera.z, 2);
    const db = Math.pow(b.x - camera.x, 2) + Math.pow(b.y - camera.y, 2) + Math.pow(b.z - camera.z, 2);
    return db - da;
});
visible.forEach(v => drawTile(v.x, v.y, v.z, tiles[v.key]));
for (const id in cursors) {
    const c = cursors[id];
    if (!c.hidden) {
        const proj = project(c.x, c.y, c.z);
        ctx.fillStyle = "#ff00ff";
        ctx.fillRect(proj.x - 2, proj.y - 2, 4, 4);
    }
}
}

function fetchRegion() {
const r = 3;
if (!ws) return;
ws.send(JSON.stringify({
    kind: "fetch",
    regions: [{ xMin: camera.x - r, xMax: camera.x + r, yMin: camera.y - r, yMax: camera.y + r, zMin: camera.z - r, zMax: camera.z + r }]
}));
}

function connect() {
ws = new WebSocket('ws://' + window.location.host);
ws.onopen = () => { console.log('connected'); fetchRegion(); };
ws.onerror = (e) => { console.error('ws error', e); };
ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    if (data.kind === "init") wsId = data.id;
    if (data.kind === "tileUpdate") Object.assign(tiles, data.updates);
    if (data.kind === "fetch") Object.assign(tiles, data.tiles);
    if (data.kind === "cursor") cursors[data.id] = data.hidden ? null : data.position;
    if (data.kind === "chat") console.log('chat:', data);
};
}
connect();

function sendCursor() {
if (!ws) return;
ws.send(JSON.stringify({ kind: "cursor", position: { x: camera.x, y: camera.y, z: camera.z }, hidden: false }));
}

function writeAtCursor(char, direction) {
if (!ws) return;
ws.send(JSON.stringify({
    kind: "write",
    edits: [[Math.floor(camera.x), Math.floor(camera.y), Math.floor(camera.z), 0, char, direction, selectedColor, -1]]
}));
}

function keyDown(e) {
keys[e.key] = true;
if (e.key === 'Control') e.preventDefault();
}
function keyUp(e) { keys[e.key] = false; }
window.addEventListener('keydown', keyDown);
window.addEventListener('keyup', keyUp);

function update() {
let moved = false;
const speed = 0.2;
if (keys['ArrowUp']) { camera.x += speed; moved = true; }
if (keys['ArrowDown']) { camera.x -= speed; moved = true; }
if (keys['ArrowLeft']) { camera.z += speed; moved = true; }
if (keys['ArrowRight']) { camera.z -= speed; moved = true; }
if (keys['Control'] && keys['ArrowUp']) { camera.y -= speed; moved = true; }
if (keys['Control'] && keys['ArrowDown']) { camera.y += speed; moved = true; }
if (moved) sendCursor();
}

canvas.addEventListener('mousedown', (e) => { mouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('mousemove', (e) => {
if (!mouseDown) return;
camera.yaw += (e.clientX - lastMouseX) * 0.01;
camera.pitch += (e.clientY - lastMouseY) * 0.01;
lastMouseX = e.clientX; lastMouseY = e.clientY;
});

canvas.addEventListener('click', (e) => {
if (mode === 'write') {
    document.getElementById('textInput').style.display = 'block';
    document.getElementById('charInput').focus();
}
if (mode === 'delete') {
    writeAtCursor(" ", "x+");
}
});

document.getElementById('confirmText').onclick = () => {
const char = document.getElementById('charInput').value;
const dir = document.getElementById('dirSelect').value;
if (char) writeAtCursor(char, dir);
document.getElementById('textInput').style.display = 'none';
document.getElementById('charInput').value = '';
};
document.getElementById('cancelText').onclick = () => {
document.getElementById('textInput').style.display = 'none';
document.getElementById('charInput').value = '';
};

document.getElementById('writeBtn').onclick = () => { mode = 'write'; modeEl.textContent = 'write'; };
document.getElementById('deleteBtn').onclick = () => { mode = 'delete'; modeEl.textContent = 'delete'; };
document.getElementById('colorPicker').onchange = (e) => {
selectedColor = parseInt(e.target.value.slice(1), 16);
};

const mobileContainer = document.getElementById('mobileControls');
document.getElementById('toggleMobile').onclick = () => {
const vis = mobileContainer.style.display;
mobileContainer.style.display = vis === 'block' ? 'none' : 'block';
};

function mobileMove(dx, dy, dz) {
camera.x += dx * 0.3;
camera.y += dy * 0.3;
camera.z += dz * 0.3;
sendCursor();
}

document.getElementById('mUp').onclick = () => mobileMove(1, 0, 0);
document.getElementById('mDown').onclick = () => mobileMove(-1, 0, 0);
document.getElementById('mLeft').onclick = () => mobileMove(0, 0, 1);
document.getElementById('mRight').onclick = () => mobileMove(0, 0, -1);
document.getElementById('mYup').onclick = () => mobileMove(0, -1, 0);
document.getElementById('mYdown').onclick = () => mobileMove(0, 1, 0);

document.getElementById('chatInput').addEventListener('keypress', (e) => {
if (e.key === 'Enter' && e.target.value.trim()) {
    if (ws) ws.send(JSON.stringify({ kind: "chat", message: e.target.value.trim(), nickname: "User" }));
    e.target.value = '';
}
});

function render() {
update();
posEl.textContent = `${camera.x.toFixed(1)},${camera.y.toFixed(1)},${camera.z.toFixed(1)}`;
dirEl.textContent = `x+,y+,z+`;
draw();
requestAnimationFrame(render);
}
render();
setInterval(fetchRegion, 2000);
</script>
</body>
</html>
