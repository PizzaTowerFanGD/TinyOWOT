<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>tinyowot 3d</title>
    <style>
        body { margin: 0; overflow: hidden; background: #eee; font-family: 'Courier New', monospace; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; image-rendering: pixelated; }

        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; background: rgba(255,255,255,0.9); border: 1px solid #999; padding: 6px; margin: 6px; display: inline-block; vertical-align: top; font-size: 13px; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); }

        #coords { position: fixed; bottom: 5px; left: 5px; font-size: 11px; color: #444; pointer-events: none; }
        #hint { position: fixed; bottom: 5px; right: 5px; font-size: 11px; color: #444; pointer-events: none; text-align: right; }

        #hidden-input { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; border: none; padding: 0; z-index: -1; pointer-events: none; }

        #mobile-controls { position: fixed; left: 10px; bottom: 40px; pointer-events: none; z-index: 20; }
        #mobile-controls .panel { pointer-events: auto; }
        #mobile-controls button { width: 46px; height: 46px; margin: 2px; font-size: 16px; }
        #mobile-toggle { position: fixed; left: 10px; bottom: 10px; z-index: 21; pointer-events: auto; }

        button { cursor: pointer; padding: 4px 8px; font-size: 12px; }
        select { font-size: 12px; }

        .row { display: flex; align-items: center; gap: 6px; margin-top: 6px; flex-wrap: wrap; }
        .label { font-size: 12px; color: #333; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="panel">
            <div class="label">tinyowot 3d</div>
            <div class="row">
                <span class="label">dir</span>
                <select id="dir-select">
                    <option value="x+">x+</option>
                    <option value="x-">x-</option>
                    <option value="y+">y+</option>
                    <option value="y-">y-</option>
                    <option value="z+">z+</option>
                    <option value="z-">z-</option>
                </select>
                <button id="btn-center">center</button>
            </div>
            <div class="row">
                <span class="label">mouse</span>
                <button id="btn-mouse-pan">pan</button>
                <button id="btn-mouse-look">look</button>
            </div>
        </div>
    </div>

    <button id="mobile-toggle">controls</button>
    <div id="mobile-controls" style="display:none;">
        <div class="panel">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <div>
                    <button data-move="up">↑</button>
                </div>
                <div>
                    <button data-move="left">←</button>
                    <button data-move="down">↓</button>
                    <button data-move="right">→</button>
                </div>
                <div style="margin-top:6px;">
                    <button data-move="y+">y+</button>
                    <button data-move="y-">y-</button>
                </div>
            </div>
        </div>
    </div>

    <div id="coords">x: 0, y: 0, z: 0</div>
    <div id="hint">arrows: x/z, ctrl+up/down: y<br>tap: select, type: write, shift+arrows: rotate</div>

    <input type="text" id="hidden-input" autocomplete="off" autocapitalize="off" spellcheck="false" />
    <canvas id="world"></canvas>

    <script>
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');
        const hiddenInput = document.getElementById('hidden-input');
        const coordsEl = document.getElementById('coords');
        const dirSelect = document.getElementById('dir-select');

        const TILE_W = 16, TILE_H = 8;
        const CHAR_W = 10, CHAR_H = 20;

        const VIEW_W_TILES = 9;
        const VIEW_H_TILES = 7;

        const BG = '#eee';

        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

        // 3d grid: tile coords are (tx, ty, tz).
        // in-tile is 16x8 cells: cx, cy.
        const tiles3d = {}; // key: `${tz},${ty},${tx}` -> tile

        function tileKey(tx, ty, tz) { return `${tz},${ty},${tx}`; }

        function getOrInitTile3d(tx, ty, tz) {
            const key = tileKey(tx, ty, tz);
            if (tiles3d[key]) return tiles3d[key];
            tiles3d[key] = {
                content: new Array(128).fill(' '),
                properties: {
                    writability: 0,
                    color: new Array(128).fill(0)
                }
            };
            return tiles3d[key];
        }

        let selected = { tx: 0, ty: 0, tz: 0, cx: 0, cy: 0 };
        let camera = { tx: 0, ty: 0, tz: 0 };

        // viewing orientation:
        // axis = which world axis is horizontal on screen
        // axis2 = which world axis is vertical on screen
        // for each, sign determines direction to the right/down
        // the remaining axis is depth.
        const orientations = {
            'z+': { h: ['x', +1], v: ['y', +1], d: ['z', +1] },
            'z-': { h: ['x', -1], v: ['y', +1], d: ['z', -1] },
            'x+': { h: ['z', -1], v: ['y', +1], d: ['x', +1] },
            'x-': { h: ['z', +1], v: ['y', +1], d: ['x', -1] },
            'y+': { h: ['x', +1], v: ['z', -1], d: ['y', +1] },
            'y-': { h: ['x', +1], v: ['z', +1], d: ['y', -1] }
        };

        function curOri() { return orientations[dirSelect.value] || orientations['z+']; }

        function worldFromScreenTile(sx, sy, depthDelta = 0) {
            // sx,sy are offsets in tile units from camera center.
            const ori = curOri();
            const out = { x: camera.tx, y: camera.ty, z: camera.tz };
            out[ori.h[0]] += sx * ori.h[1];
            out[ori.v[0]] += sy * ori.v[1];
            out[ori.d[0]] += depthDelta * ori.d[1];
            return out;
        }

        function screenFromWorldTile(tx, ty, tz) {
            const ori = curOri();
            const dx = { x: tx - camera.tx, y: ty - camera.ty, z: tz - camera.tz };
            const sx = dx[ori.h[0]] * ori.h[1];
            const sy = dx[ori.v[0]] * ori.v[1];
            const sd = dx[ori.d[0]] * ori.d[1];
            return { sx, sy, sd };
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        }
        window.addEventListener('resize', resize);
        resize();

        function render() {
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tilePxW = TILE_W * CHAR_W;
            const tilePxH = TILE_H * CHAR_H;

            const baseX = Math.floor(canvas.width / 2 - (VIEW_W_TILES * tilePxW) / 2);
            const baseY = Math.floor(canvas.height / 2 - (VIEW_H_TILES * tilePxH) / 2);

            // draw depth layers back-to-front.
            const maxDepth = 4;
            for (let depth = maxDepth; depth >= 0; depth--) {
                const alpha = 1 - depth * 0.16;
                const offset = depth * 18;

                for (let sy = 0; sy < VIEW_H_TILES; sy++) {
                    for (let sx = 0; sx < VIEW_W_TILES; sx++) {
                        const wx = sx - Math.floor(VIEW_W_TILES / 2);
                        const wy = sy - Math.floor(VIEW_H_TILES / 2);
                        const world = worldFromScreenTile(wx, wy, depth);
                        const tile = getOrInitTile3d(world.x, world.y, world.z);

                        const px = baseX + sx * tilePxW + offset;
                        const py = baseY + sy * tilePxH + offset;

                        ctx.save();
                        ctx.globalAlpha = alpha;
                        drawTile(tile, px, py);
                        ctx.restore();

                        // selection highlight for front-most layer only.
                        if (depth === 0 && world.x === selected.tx && world.y === selected.ty && world.z === selected.tz) {
                            const cellPxX = px + selected.cx * CHAR_W;
                            const cellPxY = py + selected.cy * CHAR_H;
                            ctx.strokeStyle = '#007bff';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(cellPxX, cellPxY, CHAR_W, CHAR_H);
                        }
                    }
                }
            }

            coordsEl.textContent = `x: ${selected.tx * TILE_W + selected.cx}, y: ${selected.ty * TILE_H + selected.cy}, z: ${selected.tz}`;
        }

        function drawTile(tile, px, py) {
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 1;
            ctx.fillRect(px, py, TILE_W * CHAR_W, TILE_H * CHAR_H);
            ctx.strokeRect(px, py, TILE_W * CHAR_W, TILE_H * CHAR_H);

            ctx.font = `${CHAR_H - 2}px Courier New, monospace`;
            ctx.textBaseline = 'top';

            for (let cy = 0; cy < TILE_H; cy++) {
                for (let cx = 0; cx < TILE_W; cx++) {
                    const idx = cy * TILE_W + cx;
                    const ch = (tile.content[idx] || ' ')[0];
                    ctx.fillStyle = '#000';
                    ctx.fillText(ch, px + cx * CHAR_W + 1, py + cy * CHAR_H + 1);
                }
            }
        }

        function moveSelection(worldAxis, delta) {
            selected[worldAxis] += delta;
            camera[worldAxis] += delta;
            render();
        }

        function moveSelectionInPlane(dir) {
            const ori = curOri();
            if (dir === 'left') moveSelection(ori.h[0], -1 * ori.h[1]);
            if (dir === 'right') moveSelection(ori.h[0], +1 * ori.h[1]);
            if (dir === 'up') moveSelection(ori.v[0], -1 * ori.v[1]);
            if (dir === 'down') moveSelection(ori.v[0], +1 * ori.v[1]);
        }

        function moveDepth(delta) {
            const ori = curOri();
            moveSelection(ori.d[0], delta * ori.d[1]);
        }

        function rotateDir(delta) {
            const order = ['z+', 'x+', 'z-', 'x-'];
            const cur = dirSelect.value;
            const idx = order.indexOf(cur);
            if (idx === -1) return;
            dirSelect.value = order[(idx + delta + order.length) % order.length];
            render();
        }

        // typing
        function writeChar(ch) {
            if (ch === '\n' || ch === '\r') return;
            const tile = getOrInitTile3d(selected.tx, selected.ty, selected.tz);
            const idx = selected.cy * TILE_W + selected.cx;
            tile.content[idx] = ch;

            // advance in current dir.
            const dir = dirSelect.value;
            if (dir.startsWith('x')) {
                const step = dir.endsWith('+') ? 1 : -1;
                selected.cx += step;
                while (selected.cx < 0) { selected.cx += TILE_W; selected.tx -= 1; }
                while (selected.cx >= TILE_W) { selected.cx -= TILE_W; selected.tx += 1; }
            } else if (dir.startsWith('y')) {
                const step = dir.endsWith('+') ? 1 : -1;
                selected.cy += step;
                while (selected.cy < 0) { selected.cy += TILE_H; selected.ty -= 1; }
                while (selected.cy >= TILE_H) { selected.cy -= TILE_H; selected.ty += 1; }
            } else if (dir.startsWith('z')) {
                const step = dir.endsWith('+') ? 1 : -1;
                selected.tz += step;
                camera.tz += step;
            }
            render();
        }

        hiddenInput.addEventListener('input', () => {
            const v = hiddenInput.value;
            hiddenInput.value = '';
            for (const ch of v) writeChar(ch);
        });

        document.addEventListener('keydown', (e) => {
            if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;

            if (e.key === 'ArrowLeft') { e.preventDefault(); if (e.shiftKey) rotateDir(-1); else moveSelectionInPlane('left'); return; }
            if (e.key === 'ArrowRight') { e.preventDefault(); if (e.shiftKey) rotateDir(+1); else moveSelectionInPlane('right'); return; }
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (e.ctrlKey) moveSelection('y', -1);
                else if (e.shiftKey) dirSelect.value = dirSelect.value.startsWith('y') ? (dirSelect.value === 'y+' ? 'y-' : 'y+') : 'y+';
                else moveSelectionInPlane('up');
                render();
                return;
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (e.ctrlKey) moveSelection('y', +1);
                else if (e.shiftKey) dirSelect.value = dirSelect.value.startsWith('y') ? (dirSelect.value === 'y+' ? 'y-' : 'y+') : 'y-';
                else moveSelectionInPlane('down');
                render();
                return;
            }

            if (e.key === 'PageUp') { e.preventDefault(); moveDepth(-1); return; }
            if (e.key === 'PageDown') { e.preventDefault(); moveDepth(+1); return; }

            if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                e.preventDefault();
                writeChar(e.key);
                return;
            }

            if (e.key === 'Backspace') {
                e.preventDefault();
                writeChar(' ');
                return;
            }
        });

        // mouse/touch controls
        let mouseMode = 'pan';
        const btnMousePan = document.getElementById('btn-mouse-pan');
        const btnMouseLook = document.getElementById('btn-mouse-look');
        function setMouseMode(m) {
            mouseMode = m;
            btnMousePan.disabled = m === 'pan';
            btnMouseLook.disabled = m === 'look';
        }
        btnMousePan.addEventListener('click', () => setMouseMode('pan'));
        btnMouseLook.addEventListener('click', () => setMouseMode('look'));
        setMouseMode('pan');

        let dragging = false;
        let last = { x: 0, y: 0 };
        canvas.addEventListener('pointerdown', (e) => {
            canvas.setPointerCapture(e.pointerId);
            dragging = true;
            last = { x: e.clientX, y: e.clientY };
            // tap selects.
            selectFromPoint(e.clientX, e.clientY);
            hiddenInput.focus();
        });
        canvas.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - last.x;
            const dy = e.clientY - last.y;
            last = { x: e.clientX, y: e.clientY };

            if (mouseMode === 'pan') {
                const tilePxW = TILE_W * CHAR_W;
                const tilePxH = TILE_H * CHAR_H;
                const txMove = Math.round(dx / tilePxW);
                const tyMove = Math.round(dy / tilePxH);
                if (txMove !== 0 || tyMove !== 0) {
                    const ori = curOri();
                    camera[ori.h[0]] -= txMove * ori.h[1];
                    camera[ori.v[0]] -= tyMove * ori.v[1];
                    selected[ori.h[0]] -= txMove * ori.h[1];
                    selected[ori.v[0]] -= tyMove * ori.v[1];
                    render();
                }
            } else {
                // look: horizontal drags rotate among z/x, vertical drags adjust depth.
                if (Math.abs(dx) > 20) rotateDir(dx > 0 ? +1 : -1);
                if (Math.abs(dy) > 30) moveDepth(dy > 0 ? +1 : -1);
            }
        });
        canvas.addEventListener('pointerup', () => { dragging = false; });
        canvas.addEventListener('pointercancel', () => { dragging = false; });

        function selectFromPoint(x, y) {
            const tilePxW = TILE_W * CHAR_W;
            const tilePxH = TILE_H * CHAR_H;
            const baseX = Math.floor(canvas.width / 2 - (VIEW_W_TILES * tilePxW) / 2);
            const baseY = Math.floor(canvas.height / 2 - (VIEW_H_TILES * tilePxH) / 2);

            const relX = x - baseX;
            const relY = y - baseY;
            const sx = Math.floor(relX / tilePxW);
            const sy = Math.floor(relY / tilePxH);
            if (sx < 0 || sy < 0 || sx >= VIEW_W_TILES || sy >= VIEW_H_TILES) return;

            const wx = sx - Math.floor(VIEW_W_TILES / 2);
            const wy = sy - Math.floor(VIEW_H_TILES / 2);
            const world = worldFromScreenTile(wx, wy, 0);

            selected.tx = world.x;
            selected.ty = world.y;
            selected.tz = world.z;

            const cellX = Math.floor((relX - sx * tilePxW) / CHAR_W);
            const cellY = Math.floor((relY - sy * tilePxH) / CHAR_H);
            selected.cx = clamp(cellX, 0, TILE_W - 1);
            selected.cy = clamp(cellY, 0, TILE_H - 1);
            camera.tx = selected.tx;
            camera.ty = selected.ty;
            camera.tz = selected.tz;
            render();
        }

        // ui
        document.getElementById('btn-center').addEventListener('click', () => {
            camera.tx = selected.tx;
            camera.ty = selected.ty;
            camera.tz = selected.tz;
            render();
        });
        dirSelect.addEventListener('change', () => render());

        // mobile controls
        const mobileToggle = document.getElementById('mobile-toggle');
        const mobileControls = document.getElementById('mobile-controls');
        mobileToggle.addEventListener('click', () => {
            mobileControls.style.display = (mobileControls.style.display === 'none') ? 'block' : 'none';
        });
        mobileControls.addEventListener('click', (e) => {
            const btn = e.target.closest('button');
            if (!btn) return;
            const mv = btn.getAttribute('data-move');
            if (mv === 'left' || mv === 'right' || mv === 'up' || mv === 'down') moveSelectionInPlane(mv);
            if (mv === 'y+') moveSelection('y', -1);
            if (mv === 'y-') moveSelection('y', +1);
            hiddenInput.focus();
        });

        // focus
        canvas.addEventListener('click', () => hiddenInput.focus());
        hiddenInput.addEventListener('blur', () => { /* allow blur */ });

        render();
    </script>
</body>
</html>
